DbContext
DbSet
DbSet
DbSet
DbSet

Migration:
Add-Migration; Update-Database

select @@servername
DESKTOP-3ARJA5B

如果用的是一个老的框架
.NET Framework
那么配置文件是写在一个xml文件里的 app.config

新的框架里一般都写在appsettings.json

tools -> NuGetPackage Manager -> Package Manager Console，把Default Project改成Infrastructure，因为DbContext在那里

接下来，在这个地方（PM>）运行Add-Migration InitialMigration（这个名字随便取），按回车, build started, build succeeded

下一步，PM> update-database, 回车

然后到SSMS里面，刷新，就能看到Databases下面的MovieShop数据库了

不要在SSMS里面直接修改数据库，要回去C#里改！

用Data Annotations，其实是一种Attribute，C#里凡是[]里的都叫Attribute,例如[HttpGet]
或者
Fluent API（优先度比前者更高）

然后PM> add-migration UpdatingGenreTable, update-database

如想撤销，
Update-Database -Migration <Migration Name>，比如
Update-Database -Migration InitialMigration

接下来创建Movie table
对Movie里的实体进行定义，会使用另一种方式，Fluent API

之后
PM> add-migration CreatingMovieTable
PM> update-database

Trailer.cs里的        
public Movie Movie { get; set; }
是一个navigation property，导航属性

用link查询movie的trailer是这样子——

_dbContext.Trailer.Include(t => t.Movie).ToListAsync();

PM> add-migration CreatingTrailerTable
PM> update-database

MovieGenre，属于junction table，因为movie和genre是多对多的关系
先隐性，再显性创造

PM> add-migration CreatingMovieGenreJunctionTable
但是名字有点不太对，撤销掉
PM> remove-migration
再显式地创建这个交叉表
再次 PM> add-migration CreatingMovieGenreJunctionTable
报错，因为没有在MovieGenre表里面确立主键
需要在MovieShopDbContext.cs里面，在OnModelCreating新增一行配置
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Movie>(ConfigureMovie);
    modelBuilder.Entity<MovieGenre>(configureMovieGenre);——这一行
}
再在这个.cs里面定义这个configureMovieGenre方法
private void ConfigureMovieGenre(EntityTypeBuilder<MovieGenre> builder)
{
    builder.ToTable("MovieGenre");
    builder.HasKey(mg => new { mg.MovieId, mg.GenreId });
    
}

重新运行 PM> add-migration CreatingMovieGenreJunctionTable

---------------

接下来是作业部分，自己完成剩下来的表

已完成的：Genre, Movie, MovieGenre, Trailer

---------------

Role, User, UserRole

尝试用data annotation，果然会造成kimi提到过的，column名、表名出现复数，跟预期不符
用 PM> remove-migration 取消

----------------

Crew, MovieCrew

----------------

Review

----------------

Purchase

----------------

Favorites

----------------

20251005，如何用repository访问数据库

ApplicationCore -> Contracts ->Repository下创建接口IRepository.cs

里面写CRUD

去Infra里面的Repository文件夹，创建Repository.cs （实现类）

创建interface IMovieRepository.cs

==============

20251005，讲增删查改中的查

entity和model(viewmodel）的区别，前者是一张表，后者只是轻量的，前端所需要看到的一部分

---------------

进入UI部分的开发

partial view

用bootstrap快速创建UI，比如movieCard就可以用bootstrap的card组件

通常把partial view放在MVC - Views - Shared文件夹下

通常在MVC - wwwrot - lib里面已经有bootstrap文件夹，已经安装好了

先到views - Home - Index.cshtml里写基本布局

要想清楚，电影的详情页，要放在哪个controller里面呢？
不要全放在homecontroller，会变得过于拥挤，难以维护
因为我们想要最终网页的url是这样子的： http://movieshop.com/movies/details/1
新建MoviesController.cs

右击Details方法，添加view，叫做Details.cshtml
视图的名字要跟action的名字一致，系统就会自动匹配它们

asp-controller
asp-action
asp-route-id

----------

MovieGenre迁移不成功，有外键问题

DBCC CHECKIDENT ('dbo.ParentTable', RESEED, 0);

在Shared文件夹里add - view
partial view命名规范——以下划线开头，例如 _MovieCard.cshtml
把index.cshtml里的主件剪切黏贴进去
在index.cshtml里调用这个partial view

<partial name="" model="" />

是时候重写每一张moviecard，例如https://localhost:7008/movies/Details/16

重写infra - repositories - MovieRepository.cs

需要不同表的信息，不仅仅是movies，还有genre、user等等，所以需要用Include / ThenInclude来代替sql里的join

如果我们现在在sql里面

SELECT m.*, mg.*
FROM Movie m
LEFT JOIN MovieGenre mg
ON m.Id = mg.MovieId

SELECT m.*, mg.*, g.*
FROM Movie m
Left JOIN MovieGenre mg ON m.Id = mg.MovieId
Left JOIN Genre g ON mg.GenreId = g.Id
--------------

20251008，讲同步/异步
synchronous asynchronous
CPU-bound operations I/O-bound operations

GET http://movieshop.com/movies/details/22
thread pool: T1, T2, ..., T10
503 Service Unavailable

两种可能解决方法

scale up vertically - 加强CPU, 内存etc
vs
scale out horizontally - 多买几台服务器
但都不是治本

async/await

在MoviesController.cs 里面 MoviesController的Details方法里加上async关键字
public async Task<IActionResult> Details(int id) //http://movieshop.com/movies/details/1
{
    var movieDetails = await _movieService.GetMovieDetails(id);

    return View(movieDetails);
}
意思是，我会异步返回一个Task<IActionResult>，但是要等GetMovieDetails执行完才行
await表示，后面的GetMovieDetails是一个耗时很长的事情，等这个做完了再去执行后面的return代码

IMovieService.cs里面的GetMovieDetails的返回类型也要改为Task<MovieDetailModel>

然后去MovieService，把对应的方法也同步更新

去IRepository里面，把GetById等方法的返回值也加上Task

    public interface IRepository <T> where T : class
    {
        Task<T> GetById(int id);
        Task<IEnumerable<T>> GetAll();
        Task<T> Add(T entity);
        Task<T> Update(T entity);
        Task<T> Delete(T entity);
    }

因为这些方法本质上都是I/O的工作，同步执行这些方法都有可能阻塞线程

然后去Repository.cs的实现类里面做相应改动

MovieRepository.cs里面，FirstOrDefault, Average这两个方法是同步方法，会阻塞线程
所以不但要改方法签名，还要把里面的方法也改成异步

（我现在的average rating计算是在MovieService.cs - movieDetails里的public MovieDetailModel GetMovieDetails(int id)，跟老师的不同！）

ToList也是同步版本，也要改为ToListAsync

========

part2 

http://movieshop.com/movies/genres/1

只需要用到Movie MovieGenre两张表
显示不了那么多，引入分页功能OFFSET/FETCH

select m.id, m.posterUrl, m.title
from dbo.Movie m
join dbo.MovieGenre mg on m.id = mg.movieid
where mg.genreID = 1
ORDER BY m.Id --Order by is required for OFFSET/FETCH
OFFSET 0 ROWS FETCH NEXT 30 ROWS ONLY;

在第几页，需要跳过多少部电影 公式：(pageNumber - 1) * pageSize

(2 - 1) * 30 = 30
(3 - 1) * 30 = 60

OFFSET 0 ROWS FETCH NEXT 30 ROWS ONLY; -- 这里改成
OFFSET (@pageNumber - 1) * @pageSize ROWS FETCH NEXT @pageSize ROWS ONLY;

skip(n) take(m)

skip(0).take(30); --第一页，跳过0条，取30部电影
skip(30).take(30) --第二页，跳过30条，取30条

现在来实际上写这分页逻辑，从MoviesController开始

http://movieshop.com/movies/genre/1?pageSize=30&pageNumber=2

movieshop.com -- url
movies -- controller
genre -- action method

去IMovieRepository定义一个方法GetMoviesByGenres

    public class PagedResultSet<T> where T : class
泛型，可以用在Movie上，可以用在User上，可以用在Review、MovieCard上etc

回到IMovieRepository.cs，把这个方法的返回值写完
        Task<PagedResultSet<Movie>> GetMoviesByGenres(int genreId, int pageSize = 30, int pageNumber = 1);

再去MovieRepository实现这个方法

去bootstrap pagination 拷贝Overview里面的代码，用在Genres.cshtml里面

<a href="/Movies/Genres/X?pageNumber=1">1</a>  --例如 /Movies?pageNumber=3

<a class="page-link" asp-route-pageNumber="@i">@i</a>
等价于（最终渲染）：
<a class="page-link" href="?pageNumber=3">3</a>


asp-controller asp-action

==============

20251009

Authentication Authorization 认证和授权

register 页面

username
Password

First Name
Last Name

http://movieshop.com/account/register
http://movieshop.com/account/login

login

在controller添加AccountController，在里面添加register和login的方法

为了login需要创建新的viewmodel，LoginModel，还要RegisterModel

可以记录username，但是对密码必须进行哈希处理

还需要salt，在对密码进行哈希处理之前，再添加一个随机的string

infrastructure右键， 安装Nuget KeyDerivation

Hash passwords in ASP.NET Core

byte[] salt = RandomNumberGenerator.GetBytes(128 / 8); // divide by 8 to convert bits to bytes
Console.WriteLine($"Salt: {Convert.ToBase64String(salt)}");

string hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
    password: password!,
    salt: salt,
    prf: KeyDerivationPrf.HMACSHA256,
    iterationCount: 100000,
    numBytesRequested: 256 / 8));

Console.WriteLine($"Hashed: {hashed}");

============

20251011

实现login相关的逻辑

在accountcontroller.cs里更新post的login方法

实现AccountService.cs里面的ValidateUser方法

https://localhost:7008/user/purchases

https://localhost:7008/user/favorites

创建user Controller，再实现purchase和favorite的action method

假设一个场景:

10:00 AM - logged on MovieShop website

Cookie created and sent to Browser

10:05 AM - visit purchases page

10:05的时候，如何确认这个用户已经通过了登录认证呢？

需要用到Cookie

AccountService - validateUser的返回值要从bool改为别的

core - model - 添加 UserInfoModel.cs

要去program.cs里面配置cookie的认证方案

中间件管道middleware pipeline，用来在ASP.NET CORE的请求管道中处理HTTP请求和HTTP响应的

假设用户输入了url ： http://movieshop.com/home/index

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();

用户登录之后，先从HTTPCONTEXT里面取出用户的id，用这id查出该用户购买的电影，之后把得到的结果传给视图进行展示

==================

20251012，修改layout文件
Views - Shared - _Layout.cshtml

container里面的RenderBody是一个占位符

新建一个partial view，_LoginInfo.cshtml

在MVC下面创建文件夹Services，在里面添加Interface ICurrentUser.cs，以及它的实现类CurrentUser.cs

这里我们把接口和接口实现都放在MVC层，因为它们都是web层的东西

IHttpContextAccessor，让我们在应用程序的任何地方，都能访问http上下文

需要在_Layout里引用_LoginInfo

到AccountController.cs里面实现logout方法

data-val (val是validation)

data-val-length

data-val-required

ModelState["field name"].AttemptedValue
ModelState["field name"].Errors

ModelState.IsValid

在Core创建Validators文件夹

===================

20251015，设立RESTFUL API

http://api.movieshop.com/Get30HighestGrossingMovies

API - application programming interface

REST风格

GET http://api.movieshop.com/details/1

POST http://api.movieshop.com/account/login
POST http://api.movieshop.com/account/register

右击Solution MovieShop，创建新project - ASP.NET Core Web API

API返回的不是view

Ok(...)
NotFound(...)
BadRequest(...)

右击API，set as startup project

运行，就会进入localhost:7152/swagger/index.html

在web API中，建议为每个action method都标注对应的Http attribute

[HttpGet]
[HttpPost]
[HttpPut]
[HttpDelete]

Postman，一个常用的API测试工具

/api/movies/1

http://localhost:xxxx/api/movies/1

/api/account/login
/api/account/register

{
    "email": "kimi1@test.com",
    "password": "123"
}