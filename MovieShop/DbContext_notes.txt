DbContext
DbSet
DbSet
DbSet
DbSet

Migration:
Add-Migration; Update-Database

select @@servername
DESKTOP-3ARJA5B

如果用的是一个老的框架
.NET Framework
那么配置文件是写在一个xml文件里的 app.config

新的框架里一般都写在appsettings.json

tools -> NuGetPackage Manager -> Package Manager Console，把Default Project改成Infrastructure，因为DbContext在那里

接下来，在这个地方（PM>）运行Add-Migration InitialMigration（这个名字随便取），按回车, build started, build succeeded

下一步，PM> update-database, 回车

然后到SSMS里面，刷新，就能看到Databases下面的MovieShop数据库了

不要在SSMS里面直接修改数据库，要回去C#里改！

用Data Annotations，其实是一种Attribute，C#里凡是[]里的都叫Attribute,例如[HttpGet]
或者
Fluent API（优先度比前者更高）

然后PM> add-migration UpdatingGenreTable, update-database

如想撤销，
Update-Database -Migration <Migration Name>，比如
Update-Database -Migration InitialMigration

接下来创建Movie table
对Movie里的实体进行定义，会使用另一种方式，Fluent API

之后
PM> add-migration CreatingMovieTable
PM> update-database

Trailer.cs里的        
public Movie Movie { get; set; }
是一个navigation property，导航属性

用link查询movie的trailer是这样子——

_dbContext.Trailer.Include(t => t.Movie).ToListAsync();

PM> add-migration CreatingTrailerTable
PM> update-database

MovieGenre，属于junction table，因为movie和genre是多对多的关系
先隐性，再显性创造

PM> add-migration CreatingMovieGenreJunctionTable
但是名字有点不太对，撤销掉
PM> remove-migration
再显式地创建这个交叉表
再次 PM> add-migration CreatingMovieGenreJunctionTable
报错，因为没有在MovieGenre表里面确立主键
需要在MovieShopDbContext.cs里面，在OnModelCreating新增一行配置
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Movie>(ConfigureMovie);
    modelBuilder.Entity<MovieGenre>(configureMovieGenre);——这一行
}
再在这个.cs里面定义这个configureMovieGenre方法
private void ConfigureMovieGenre(EntityTypeBuilder<MovieGenre> builder)
{
    builder.ToTable("MovieGenre");
    builder.HasKey(mg => new { mg.MovieId, mg.GenreId });
    
}

重新运行 PM> add-migration CreatingMovieGenreJunctionTable

---------------

接下来是作业部分，自己完成剩下来的表

已完成的：Genre, Movie, MovieGenre, Trailer

---------------

Role, User, UserRole

尝试用data annotation，果然会造成kimi提到过的，column名、表名出现复数，跟预期不符
用 PM> remove-migration 取消

----------------

Crew, MovieCrew

----------------

Review

----------------

Purchase

----------------

Favorites

----------------

20251005，如何用repository访问数据库

ApplicationCore -> Contracts ->Repository下创建接口IRepository.cs

里面写CRUD

去Infra里面的Repository文件夹，创建Repository.cs （实现类）

创建interface IMovieRepository.cs

==============

20251005，讲增删查改中的查

entity和model(viewmodel）的区别，前者是一张表，后者只是轻量的，前端所需要看到的一部分

---------------

进入UI部分的开发

partial view

用bootstrap快速创建UI，比如movieCard就可以用bootstrap的card组件

通常把partial view放在MVC - Views - Shared文件夹下

通常在MVC - wwwrot - lib里面已经有bootstrap文件夹，已经安装好了

先到views - Home - Index.cshtml里写基本布局

要想清楚，电影的详情页，要放在哪个controller里面呢？
不要全放在homecontroller，会变得过于拥挤，难以维护
因为我们想要最终网页的url是这样子的： http://movieshop.com/movies/details/1
新建MoviesController.cs

右击Details方法，添加view，叫做Details.cshtml
视图的名字要跟action的名字一致，系统就会自动匹配它们

asp-controller
asp-action
asp-route-id

----------

MovieGenre迁移不成功，有外键问题

DBCC CHECKIDENT ('dbo.ParentTable', RESEED, 0);

在Shared文件夹里add - view
partial view命名规范——以下划线开头，例如 _MovieCard.cshtml
把index.cshtml里的主件剪切黏贴进去
在index.cshtml里调用这个partial view

<partial name="" model="" />

是时候重写每一张moviecard，例如https://localhost:7008/movies/Details/16

重写infra - repositories - MovieRepository.cs

需要不同表的信息，不仅仅是movies，还有genre、user等等，所以需要用Include / ThenInclude来代替sql里的join

如果我们现在在sql里面

SELECT m.*, mg.*
FROM Movie m
LEFT JOIN MovieGenre mg
ON m.Id = mg.MovieId

SELECT m.*, mg.*, g.*
FROM Movie m
Left JOIN MovieGenre mg ON m.Id = mg.MovieId
Left JOIN Genre g ON mg.GenreId = g.Id
--------------

20251008，讲同步/异步
synchronous asynchronous
CPU-bound operations I/O-bound operations

GET http://movieshop.com/movies/details/22
thread pool: T1, T2, ..., T10
503 Service Unavailable

两种可能解决方法

scale up vertically - 加强CPU, 内存etc
vs
scale out horizontally - 多买几台服务器
但都不是治本

async/await

在MoviesController.cs 里面 MoviesController的Details方法里加上async关键字
public async Task<IActionResult> Details(int id) //http://movieshop.com/movies/details/1
{
    var movieDetails = await _movieService.GetMovieDetails(id);

    return View(movieDetails);
}
意思是，我会异步返回一个Task<IActionResult>，但是要等GetMovieDetails执行完才行
await表示，后面的GetMovieDetails是一个耗时很长的事情，等这个做完了再去执行后面的return代码

IMovieService.cs里面的GetMovieDetails的返回类型也要改为Task<MovieDetailModel>

然后去MovieService，把对应的方法也同步更新

去IRepository里面，把GetById等方法的返回值也加上Task

    public interface IRepository <T> where T : class
    {
        Task<T> GetById(int id);
        Task<IEnumerable<T>> GetAll();
        Task<T> Add(T entity);
        Task<T> Update(T entity);
        Task<T> Delete(T entity);
    }

因为这些方法本质上都是I/O的工作，同步执行这些方法都有可能阻塞线程

然后去Repository.cs的实现类里面做相应改动

MovieRepository.cs里面，FirstOrDefault, Average这两个方法是同步方法，会阻塞线程
所以不但要改方法签名，还要把里面的方法也改成异步

（我现在的average rating计算是在MovieService.cs - movieDetails里的public MovieDetailModel GetMovieDetails(int id)，跟老师的不同！）

ToList也是同步版本，也要改为ToListAsync

========

part2 

http://movieshop.com/movies/genres/1

只需要用到Movie MovieGenre两张表
显示不了那么多，引入分页功能OFFSET/FETCH

select m.id, m.posterUrl, m.title
from dbo.Movie m
join dbo.MovieGenre mg on m.id = mg.movieid
where mg.genreID = 1
ORDER BY m.Id --Order by is required for OFFSET/FETCH
OFFSET 0 ROWS FETCH NEXT 30 ROWS ONLY;

在第几页，需要跳过多少部电影 公式：(pageNumber - 1) * pageSize

(2 - 1) * 30 = 30
(3 - 1) * 30 = 60

OFFSET 0 ROWS FETCH NEXT 30 ROWS ONLY; -- 这里改成
OFFSET (@pageNumber - 1) * @pageSize ROWS FETCH NEXT @pageSize ROWS ONLY;

skip(n) take(m)

skip(0).take(30); --第一页，跳过0条，取30部电影
skip(30).take(30) --第二页，跳过30条，取30条

现在来实际上写这分页逻辑，从MoviesController开始

http://movieshop.com/movies/genre/1?pageSize=30&pageNumber=2

movieshop.com -- url
movies -- controller
genre -- action method

去IMovieRepository定义一个方法GetMoviesByGenres

    public class PagedResultSet<T> where T : class
泛型，可以用在Movie上，可以用在User上，可以用在Review、MovieCard上etc

回到IMovieRepository.cs，把这个方法的返回值写完
        Task<PagedResultSet<Movie>> GetMoviesByGenres(int genreId, int pageSize = 30, int pageNumber = 1);

再去MovieRepository实现这个方法

去bootstrap pagination 拷贝Overview里面的代码，用在Genres.cshtml里面

<a href="/Movies/Genres/X?pageNumber=1">1</a>  --例如 /Movies?pageNumber=3

<a class="page-link" asp-route-pageNumber="@i">@i</a>
等价于（最终渲染）：
<a class="page-link" href="?pageNumber=3">3</a>


asp-controller asp-action

==============

20251009

Authentication Authorization 认证和授权

register 页面

username
Password

First Name
Last Name

http://movieshop.com/account/register
http://movieshop.com/account/login

login

在controller添加AccountController，在里面添加register和login的方法

为了login需要创建新的viewmodel，LoginModel，还要RegisterModel

可以记录username，但是对密码必须进行哈希处理

还需要salt，在对密码进行哈希处理之前，再添加一个随机的string

infrastructure右键， 安装Nuget KeyDerivation

Hash passwords in ASP.NET Core

byte[] salt = RandomNumberGenerator.GetBytes(128 / 8); // divide by 8 to convert bits to bytes
Console.WriteLine($"Salt: {Convert.ToBase64String(salt)}");

string hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
    password: password!,
    salt: salt,
    prf: KeyDerivationPrf.HMACSHA256,
    iterationCount: 100000,
    numBytesRequested: 256 / 8));

Console.WriteLine($"Hashed: {hashed}");

============

20251011

实现login相关的逻辑

在accountcontroller.cs里更新post的login方法

实现AccountService.cs里面的ValidateUser方法

https://localhost:7008/user/purchases

https://localhost:7008/user/favorites

创建user Controller，再实现purchase和favorite的action method

假设一个场景:

10:00 AM - logged on MovieShop website

Cookie created and sent to Browser

10:05 AM - visit purchases page

10:05的时候，如何确认这个用户已经通过了登录认证呢？

需要用到Cookie

AccountService - validateUser的返回值要从bool改为别的

core - model - 添加 UserInfoModel.cs

要去program.cs里面配置cookie的认证方案

中间件管道middleware pipeline，用来在ASP.NET CORE的请求管道中处理HTTP请求和HTTP响应的

假设用户输入了url ： http://movieshop.com/home/index

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();

用户登录之后，先从HTTPCONTEXT里面取出用户的id，用这id查出该用户购买的电影，之后把得到的结果传给视图进行展示

==================

20251012，修改layout文件
Views - Shared - _Layout.cshtml

container里面的RenderBody是一个占位符

新建一个partial view，_LoginInfo.cshtml

在MVC下面创建文件夹Services，在里面添加Interface ICurrentUser.cs，以及它的实现类CurrentUser.cs

这里我们把接口和接口实现都放在MVC层，因为它们都是web层的东西

IHttpContextAccessor，让我们在应用程序的任何地方，都能访问http上下文

需要在_Layout里引用_LoginInfo

到AccountController.cs里面实现logout方法

data-val (val是validation)

data-val-length

data-val-required

ModelState["field name"].AttemptedValue
ModelState["field name"].Errors

ModelState.IsValid

在Core创建Validators文件夹

===================

20251015，设立RESTFUL API

http://api.movieshop.com/Get30HighestGrossingMovies

API - application programming interface

REST风格

GET http://api.movieshop.com/details/1

POST http://api.movieshop.com/account/login
POST http://api.movieshop.com/account/register

右击Solution MovieShop，创建新project - ASP.NET Core Web API

API返回的不是view

Ok(...)
NotFound(...)
BadRequest(...)

右击API，set as startup project

运行，就会进入localhost:7152/swagger/index.html

在web API中，建议为每个action method都标注对应的Http attribute

[HttpGet]
[HttpPost]
[HttpPut]
[HttpDelete]

Postman，一个常用的API测试工具

/api/movies/1

http://localhost:xxxx/api/movies/1

/api/account/login
/api/account/register

{
    "email": "kimi1@test.com",
    "password": "123"
}

.NET岗位面试常见考点：C#, sql，API, MVC的面试题通常不多。
这些年，优先构建API的架构是趋势，MVC和API都要掌握

=================

20251018

今天学一种新的认证方式 json web token (JWT)，之前在MVC项目里面我们用cookie认证

jwt.io

JWT分3段，句号隔开。分别是header, payload, signature

右击solution Movieshop，安装Nuget package, 搜索Tokens.jwt, 全部勾选，安装

在appsettings.json里面设立privateKey，待会要用它生成secretKey

在AccountController.cs里面在AccountController的构造函数里注入Iconfiguration的instance

如果用token
Authorization: Bearer <token>

在API下面新增UserController.cs

进入developer powershell(VS下面栏)
 cd .\MovieShopAPI\
 dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 8.0.8

安装这个，新版的会不兼容

HTTP Interceptor

===================

20251018

Custom Middleware & Logging

优雅地处理异常

UseDeveloperExceptionPage() --适合开发环境，不适合生产环境使用
UseExceptionHandler("/Home/Error") --生产环境的错误处理中间件

DivideByZeroException: Attempted to divide by zero.
MovieShopMVC.Controllers.HomeController.Index() in HomeController.cs
+
            int z = x / y; 

-- 这种就是开发者的异常页面，会直接显示出错的源代码，在开发/测试环境里是没问题的，但是在生产环境则很危险！

在企业级应用里，通常会对异常做更多处理，通常会把异常写在日志文件里面

MVC - 新增文件夹Middlewares - 在里面添加Middleware class，叫 MovieShopExceptionMiddleware.cs

用系统自带的ILogger保存异常的log

Ilogger，或者Serilog

====================

20251019

前端项目

安装Node.js

进command prompt输入

node --version
npm --version

确认nodejs有没有装好

npm install -g @angular/cli

安装angular的cli工具

ng --version

确认安装

之前学的是MVC
今天要学SPA  single page application

公共模块
认证模块
用户模块
管理模块

懒加载 Lazy Loading

AJAX
js: fetch, XMLHttpRequest
angular: HttpClient

AngularJS --- Angular 1，到2015年
Angular2+ --- 2016重写，到现在
以TypeScript为主，而不是纯粹的JavaScript
组件是Angular中最小的构造单元
RxJS的响应式编程
Angular CLI（命令行工具）

TypeScript： 由微软在JavaScript基础上，加入了类型系统，让TypeScript变成了一个强类型语言
浏览器不能直接运行TypeScript，只能运行JavaScript，所以
.ts -> .js

Ahead-Of-Time 机制

主要使用工具是cmd

H:\OneDrive\documents\job searching\RothurTech\project\Angular>ng new movieshopspa --no-standalone
选第一个CSS，预渲染选No
下一个zoneless也选no
AI工具，先选no

在VS Code里打开文件夹，打开view - terminal

安装插件，在google doc里面有

优先用cmd而不是powershell，后者有可能遇到权限问题

ng serve --open

app.ts -- 曾经叫做appcomponent.ts

bootstrapModule -- 这里bootstrap是启动的意思，和之前学过的CSS框架里的bootstrap没有关系

启动链：

maints -> AppModule -> AppComponent -> app.html

{{}} -- interpolation 插值

c = component 组件

ng g module movies/movies --flat 
ng g module movies/movies --flat --dry-run  (尝试运行，并没有真正运行）

ng g c movies/movie-details --dry-run

ng g c home

ng g module core/core --flat

ng g module shared/shared --flat

==============

20251022

对比MVC和Angular，如何从后端拿数据

MVC: Controller → Service → Repository
Angular： Component → Service → HttpClient

http://localhost:4200/home
首先Angular会加载 AppModule
然后AppModule会激活、渲染 HomeComponent
然后在HomeComponent的主件里会调用 MovieService
MovieService会使用HttpClient向后端API发起AJAX请求，然后API会返回一组电影的json数据，前端用model接收这份json数据，
MovieService再把这数据返回给HomeComponent，Angular把数据和模版绑定之后，浏览器就会把页面渲染出来

异步代码在C#和Angular的区别

C#：

async/await

Angular:

Observables --理解成一种数据流，比promise更强

ng g s core/services/movie

生成两个文件, movie.spec.ts是测试文件，先不管，movie.ts

ng g s core/services/user

ng g s core/services/account

ng g s core/services/genre

ng g s core/services/admin

  GetMovieDetails(id: number) { // 在C#里会写 int id，类型和参数的顺序是反过来的
  }

到app-modue.ts里导入并注册httpclient module

export interface MovieCardModel {

Paste JSON as Code

先在swagger复制json
ctrl shift P， 输入Paste JSON as Code，再输入MovieCardModel，即可自动生成interface


async/await: 可以用，但通常只适合处理单次返回的请求
Observable：更通用，既能表示一次性Http响应，也能表示多次推送的数据流

lifecycle hooks --生命周期钩子

ngOnInit()  --一个主件初始化阶段就会触发的生命周期钩子

容易混淆点：构造函数不属于Angular的生命周期

构造函数：语言层面的概念
生命周期：Angular框架层面的概念

就好像.ToListAsync()不运行，就不会真正运行请求一样，.getTopGrossingMovies()后面必须加上.subscribe()
——这种叫lazy execution，惰性执行

selector:

<app-home></app-home>  --写在app.html, 有点像MVC里的一个partial view

想打开Angular的主页：在VSCODE里面进cmd，输入ng serve，出现主页地址http://localhost:4200/，复制黏贴到浏览器回车

浏览器主页右键- inspect - console

出错原因：
前端运行在http://localhost:4200/
后端运行在http://localhost:7030/

解决方法：在后端开启一个机制CORS: Cross-Origin Resource Sharing

bank.com          evil.com

whitelist: partner.com

===================

COR & ROUTING INTRO

CORS (Cross-Origin Resource Sharing）

后端API - appsettings.json加入这一行   "spaUrl": "http://localhost:4200",

然后API - program.cs加入

app.UseCors(policy =>
{
    policy.WithOrigins(builder.Configuration["spaUrl"])
        .AllowAnyMethod()
        .AllowAnyHeader()
        .AllowCredentials();
});

http://localhost:4200  -> Origin: http://localhost:4200

http://localhost:7030/  -> Access-Control-Allow-Origin: http://localhost:4200

https://localhost:7152/

cmd - npm install bootstrap@5.3.7

ng g c shared/components/movie-card  --创建movie-card的子组件


Angular的directives:

Structural directives: 结构型指令
*ngIf, *ngFor

Attribute Directive: 属性型指令
[ngClass],[ngStyle]

==================

2025102

Routing

lazy loading：建立在Modularization（模块化） + Routing之上

ng g module account/account --routing --flat

ng g module admin/admin --routing --flat

ng g module user/user --routing --flat

ng g c movies/cast-details

ng g module movies/movies-routing --flat --module=movies

每个功能都需要一个Shell Component（外壳组件）

每个Shell Component里再放一个 <router-outlet/>

ng g c movies/movies --flat    --先为movies创造外壳组件

会在movies文件夹下多出4个文件：
movies.css
movies.html
movies.spec.ts
movies.ts

在movies.html里面加上<router-outlet/>

再对剩下来的几个模块重复上述操作——创造外壳组件，并在.html里加上<router-outlet/>

ng g c account/account --flat

ng g c admin/admin --flat

ng g c user/user --flat

再进入app-routing-module.ts配置lazy loading的路由逻辑


如果：
http://localhost:4200/movies/1            --> MovieDetailsComponent (id = 1)
http://localhost:4200/movies/cast/1    --> CastDetailsComponent (id = 1)

去movies-routing-module.ts加上

const routes: Routes = [
  {
    path: '', component: Movies
  }
];